{"version":3,"sources":["BarPlotComponent.tsx","index.tsx"],"names":["NUM_EPISODES","D3_DIV_ID","_","require","BarPlotComponent","_StreamlitComponentBa","_inherits","_super","_createSuper","_this","_classCallCheck","_len","arguments","length","args","Array","_key","call","apply","concat","componentDidMount","_this$get_dimensions","get_dimensions","_this$get_dimensions2","_slicedToArray","width","height","margin","setState","zoom","svg","d3","append","attr","left","right","top","bottom","container","node","parentNode","parseInt","style","aspect","resize","targetWidth","Math","round","Streamlit","setFrameHeight","window","on","render","data","get_data","_this$get_dimensions3","_this$get_dimensions4","stTheme","get_theme","episodes","map","d","episode","toString","filter","value","index","self","indexOf","props","key","marks","i","_jsxs","children","_jsx","id","ConfigProvider","theme","token","colorPrimary","secondaryBackgroundColor","colorFillContentHover","colorPrimaryBorder","colorPrimaryBorderHover","Slider","range","min","max","step","defaultValue","onAfterChange","handleChangeEpisodeBounds","tooltip","open","disabled","duration","undefined","startEpisode","endEpisode","displayedEpisodes","select","xAxis","episodeXaxis","selectAll","each","push","e","scaleExtent","event","x","domain","newX","transform","rescaleX","ticks","tickFormat","tickSize","startTime","endTime","path","moveTo","lineTo","myZoom","cloneDeep","k","transition","_createClass","table","this","NUM_COLUMNS","columns","_loop","rowIndex","row","columnIndex","_table$getCell","getCell","content","classNames","type","act","chapter","segment","parseFloat","viewership","rows","metadata","_this2","get_metadata","_this$get_dimensions5","_this$get_dimensions6","colour","text","granularity","metric","y","state","yAxis","distinct","join","gridLineXs","textColor","target","metric_postfix","pageY","pageX","zoomedActs","colourLegend","remove","symbolSize","pow","gridWidth","calculateSaturation","hex","color","startsWith","slice","red","substr","green","blue","saturation","acts","actChapters","middleChapter","floor","square","size","sqrt","chapters","sort","a","b","aChapter","bChapter","aSat","bSat","compareChapterColours","StreamlitComponentBase","withStreamlitConnection","ReactDOM","React","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.5339a074.chunk.js","sourcesContent":["import {\n  ArrowTable,\n  Streamlit,\n  StreamlitComponentBase,\n  withStreamlitConnection\n} from 'streamlit-component-lib'\nimport React, { ReactNode } from 'react'\nimport * as d3 from 'd3'\nimport { Slider, ConfigProvider } from 'antd'\n\nconst _ = require('lodash')\n\nlet NUM_EPISODES: number\nlet D3_DIV_ID: string\n\ninterface dataObj {\n  index: number\n  episode: number\n  act: string\n  chapter: string\n  segment: string\n  startTime: number\n  endTime: number\n  viewership: number\n}\n\ninterface State {\n  zoom: [number, number]\n}\n\n/**\n * React-based Streamlit component implementing a custom bar plot meant to represent viewership data.\n * Every bar represents an individual segment its height and width representing viewership and segment length respectively.\n * The colour of each bar represents the act and chapter to which it belongs.\n * The bars are placed on the x-axis in chronological order.\n * A slider can be used to zoom to any group of sebseuent episodes.\n */\nclass BarPlotComponent extends StreamlitComponentBase<State> {\n  /**\n   * Convert the data passed by the Streamlit webpage from an ArrowTable to a DataObj[].\n   *\n   * @returns {dataObj[]} Data passed by the Streamlit webpage.\n   */\n  private get_data (): dataObj[] {\n    const table: ArrowTable = this.props.args.data\n\n    const data: dataObj[] = []\n    const NUM_COLUMNS = table.columns\n    // Itterate from 1 because of headerRow\n    for (let rowIndex = 1; rowIndex < table.rows; rowIndex++) {\n      const row = d3.range(0, NUM_COLUMNS).map((columnIndex) => {\n        const { classNames, content, id, type } = table.getCell(rowIndex, columnIndex)\n        return content?.toString()\n      })\n\n      data.push({\n        index: rowIndex,\n        episode: parseInt(row[1]),\n        act: row[2],\n        chapter: row[3],\n        segment: row[4],\n        startTime: parseFloat(row[5]),\n        endTime: parseFloat(row[6]),\n        viewership: parseFloat(row[7])\n      })\n    }\n\n    return data\n  }\n\n  /**\n   * Get the metadata passed by the Streamlit webpage.\n   *\n   * @returns {any[]} Metadata passed by the Streamlit webpage.\n   */\n  private get_metadata (): any {\n    return this.props.args.metadata\n  }\n\n  /**\n   * Get the theme passed by the Streamlit webpage.\n   *\n   * @returns {any[]} Theme passed by the Streamlit webpage.\n   */\n  private get_theme (): any {\n    return this.props.theme\n  }\n\n  /**\n   * Get the dimension for the components comprimised of width, height and margins.\n   *\n   * @returns {[number, number, { top: number, right: number, bottom: number, left: number }]} Dimensions.\n   */\n  private get_dimensions (): [number, number, { top: number, right: number, bottom: number, left: number }] {\n    const margin = { top: 30, right: 220, bottom: 30, left: 80 }\n    const width = 1200 - margin.left - margin.right\n    const height = 600 - margin.top - margin.bottom\n\n    return [width, height, margin]\n  }\n\n  public componentDidMount = (): void => {\n    const [width, height, margin] = this.get_dimensions()\n\n    // Set zoom state to completely zoomed out.\n    this.setState({ zoom: [1, NUM_EPISODES] })\n\n    // Resize the complete component to change with adjusting screensizes.\n    function resizeToFit (svg): void {\n      // Get container + svg aspect ratio.\n      const container = d3.select(svg.node().parentNode)\n      const width = parseInt(svg.style('width'))\n      const height = parseInt(svg.style('height'))\n      const aspect = width / height\n\n      // Add viewBox and preserveAspectRatio properties,\n      // and call resize so that svg resizes on inital page load.\n      svg.attr('viewBox', `0 0 ${width} ${height}`)\n        .attr('perserveAspectRatio', 'xMinYMid')\n        .call(resize)\n\n      d3.select(window).on(`resize.${container.attr('id')}`, resize)\n\n      // Get width of container and resize svg to fit it.\n      function resize (): void {\n        const targetWidth = parseInt(container.style('width'))\n        svg.attr('width', targetWidth)\n        svg.attr('height', Math.round(targetWidth / aspect))\n        Streamlit.setFrameHeight()\n      }\n    }\n\n    // Append the svg object to the body of the page.\n    const svg = d3.select('#' + D3_DIV_ID)\n      .append('svg')\n      .attr('width', width + margin.left + margin.right)\n      .attr('height', height + margin.top + margin.bottom)\n      .call(resizeToFit)\n      .append('g')\n      .attr('transform', `translate(${margin.left},${margin.top})`)\n\n    // Add a clipPath: everything out of this area won't be drawn.\n    svg.append('defs').append('svg:clipPath')\n      .attr('id', 'clip')\n      .append('svg:rect')\n      .attr('width', width)\n      .attr('height', height)\n      .attr('x', 0)\n      .attr('y', 0)\n\n    // Initialize the X and Y axis.\n    svg.append('g')\n      .attr('transform', `translate(0,${height})`)\n      .attr('id', 'myXaxis')\n    svg.append('g')\n      .attr('id', 'myYaxis')\n\n    // Initialize the tooltip.\n    d3.select('body')\n      .append('div')\n      .attr('class', 'svg-tooltip')\n      .style('font-family', '-apple-system, system-ui, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple   Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"')\n      .style('border-radius', '.1rem')\n      .style('font-size', '14px')\n      .style('max-width', '320px')\n      .style('text-overflow', 'ellipsis')\n      .style('white-space', 'pre')\n      .style('z-index', '300')\n      .style('background', 'rgba(69,77,93,.9)')\n      .style('color', '#fff')\n      .style('display', 'block')\n      .style('padding', '.2rem .4rem')\n      .style('position', 'absolute')\n      .style('visibility', 'hidden')\n\n    // Initialize the metric and granularity labels.\n    svg.append('text')\n      .attr('id', 'yLabel')\n      .attr('transform', `translate(${(width / 2)} ,${(-10)})`)\n      .style('font-size', 25)\n      .style('text-anchor', 'middle')\n    svg.append('text')\n      .attr('id', 'topLabel')\n      .attr('transform', 'rotate(-90)')\n      .attr('y', -margin.left)\n      .attr('x', -(height / 2))\n      .attr('dy', '1em')\n      .style('font-size', 25)\n      .style('text-anchor', 'middle')\n\n    // Initialize the legend.\n    svg.append('g')\n      .attr('class', 'colourLegend')\n      .attr('transform', `translate(${width + 20},${height - 20})`)\n\n    Streamlit.setFrameHeight()\n  }\n\n  public componentDidUpdate (): void {\n    const data = this.get_data()\n    const metadata = this.get_metadata()\n    const [width, height, margin] = this.get_dimensions()\n    const colour = metadata.colour\n    const stTheme = this.get_theme()\n\n    const svg = d3.select('#' + D3_DIV_ID).select('svg').select('g')\n\n    // Set the metric and granularity labels.\n    svg.select('#yLabel')\n      .text(`${metadata.granularity}`)\n    svg.select('#topLabel')\n      .text(`${metadata.metric}`)\n\n    // Initialize the x and y scales.\n    let x = d3.scaleLinear()\n      .domain([0.5, NUM_EPISODES + 0.5])\n      .range([0, width])\n    const y = d3.scaleLinear()\n      .range([height, 0])\n\n    // Rescale the X axis to adjust for previously applied zooms.\n    const startEpisode = this.state.zoom[0]\n    const endEpisode = this.state.zoom[1]\n    const displayedEpisodes = endEpisode - startEpisode + 1\n\n    const myZoom = _.cloneDeep(d3.zoomIdentity)\n    myZoom.k = NUM_EPISODES / displayedEpisodes\n    myZoom.x = (1 - startEpisode) * (width / displayedEpisodes)\n\n    x = myZoom.rescaleX(x)\n\n    const xAxis = svg.select('#myXaxis')\n    const yAxis = svg.select('#myYaxis')\n\n    const distinct = (value, index, self): boolean => {\n      return self.indexOf(value) === index\n    }\n\n    const episodes = data.map(d => d.episode).filter(distinct)\n    const episodeXaxis = {}\n\n    episodes.map((e, i) => { episodeXaxis[e] = i + 1; return 0 })\n    // Update the X axis\n    xAxis.call(d3.axisBottom(x)\n      .ticks(displayedEpisodes)\n      .tickFormat((i) => i - 1 > -1 && i - 1 < episodes.length ? `Episode ${episodes[i - 1]}` : '')\n      .tickSize(0)\n    )\n    xAxis.selectAll('.tick text')\n      .attr('font-size', `${Math.min(150 / displayedEpisodes, 20)}`)\n\n    // Update the Y axis\n    y.domain([0, d3.max(data, d => d.viewership) * 1.1])\n    yAxis.call(d3.axisLeft(y))\n\n    yAxis.selectAll('.tick text')\n      .attr('font-size', '15')\n\n    // Add a new rect for each element in data.\n    svg.selectAll('.dataRect')\n      .data(data)\n      .join('rect')\n      .attr('clip-path', 'url(#clip)')\n      .attr('x', d => x(d.startTime + episodeXaxis[d.episode] - 0.5))\n      .attr('width', d => x(d.endTime + episodeXaxis[d.episode] - 0.5) - x(d.startTime + episodeXaxis[d.episode] - 0.5))\n      .attr('y', d => y(d.viewership))\n      .attr('height', d => height - y(d.viewership))\n      .attr('fill', d => colour[d.act][d.chapter])\n      .attr('class', 'dataRect')\n      .attr('stroke-width', `${Math.min(0.7, 4 / ((displayedEpisodes)))}`)\n      .attr('stroke', 'white')\n\n    // Add gridlines between episodes for clear seperation.\n    const gridLineXs: Number[] = []\n    for (let i = 1; i < NUM_EPISODES + 1; i++) {\n      gridLineXs.push(i + 0.5)\n    }\n\n    svg.selectAll('.gridLine')\n      .data(gridLineXs)\n      .join('path')\n      .attr('clip-path', 'url(#clip)')\n      .attr('d', d => {\n        const path = d3.path()\n        path.moveTo(x(d), 0)\n        path.lineTo(x(d), height + 10)\n        return path\n      })\n      .attr('fill', 'none')\n      .attr('stroke', (stTheme != null) ? stTheme.textColor : 'rgb(150,150,150)')\n      .attr('stroke-width', 1)\n      .attr('class', 'gridLine')\n\n    // Create tooltip.\n    const tooltip = d3.select('body').select('.svg-tooltip')\n\n    d3.selectAll('.dataRect')\n      .on('mouseover', function (event, d) {\n        d3.select(event.target)\n          .attr('stroke-width-cache', d3.select(event.target).attr('stroke-width'))\n          .attr('stroke-width', '1')\n          .attr('stroke', 'black')\n\n        tooltip.style('visibility', 'visible')\n          .text(`Viewership: ${Math.round(d.viewership)}${metadata.metric_postfix}\\nEpisode: ${d.episode}\\n` +\n                            `Act: ${d.act}\\n` +\n                            (d.chapter !== 'NVT' ? `Chapter: ${d.chapter}\\n` : '') +\n                            (d.segment !== 'NVT' ? `Segment: ${d.segment}` : ''))\n      })\n      .on('mousemove', function (event) {\n        tooltip\n          .style('top', `${event.pageY - 10}px`)\n          .style('left', `${event.pageX + 10}px`)\n      })\n      .on('mouseout', function (event) {\n        // Change the selection style.\n        d3.select(event.target)\n          .attr('stroke-width', d3.select(event.target).attr('stroke-width-cache'))\n          .attr('stroke-width-cache', null)\n          .attr('stroke', 'white')\n\n        tooltip.style('visibility', 'hidden')\n      })\n\n    // Fill in legend.\n    // When multiple acts are visible the legend displays the acts.\n    // When only one act is visible the legend displays the chapters of that act.\n    const zoomedData = data.filter(d => d.episode >= this.state.zoom[0] && d.episode <= this.state.zoom[1])\n    const zoomedActs = zoomedData.map(d => d.act).filter(distinct)\n\n    const colourLegend = svg.select('.colourLegend')\n    colourLegend.selectAll('path').remove()\n    colourLegend.selectAll('text').remove()\n\n    const gridWidth = 100\n    const symbolSize = (gridWidth / 5) ** 2\n\n    // Functions used to sort the chapters by colour saturation before drawing the legend.\n    // In theory this should not be necessary but if the colourscheme is generated in a bad way,\n    // this guarentees the legend will show the colours in order from light to dark.\n    // !!!CHATGPT\n    function calculateSaturation(hex: string): number {\n      // Remove the '#' symbol if present\n      const color = hex.startsWith('#') ? hex.slice(1) : hex;\n\n      // Extract the individual RGB components\n      const red = parseInt(color.substr(0, 2), 16) / 255;\n      const green = parseInt(color.substr(2, 2), 16) / 255;\n      const blue = parseInt(color.substr(4, 2), 16) / 255;\n\n      // Find the minimum and maximum component values\n      const min = Math.min(red, green, blue);\n      const max = Math.max(red, green, blue);\n\n      // Calculate the saturation value\n      let saturation = 0;\n      if (max !== 0) {\n        const delta = max - min;\n        saturation = delta / max;\n      }\n\n      // Round the saturation value to 2 decimal places\n      saturation = Math.round(saturation * 100) / 100;\n\n      return saturation;\n    }\n\n    function compareChapterColours(act: string, aChapter: string, bChapter: string): number {\n      if (!(aChapter in colour[act] && bChapter in colour[act])) {\n        return 0\n      }\n      const aSat = calculateSaturation(colour[act][aChapter])\n      const bSat = calculateSaturation(colour[act][bChapter])\n\n      if (aSat < bSat) {\n        return -1\n      }\n      if (aSat > bSat) {\n        return 1\n      }\n      return 0\n    }\n\n    if (zoomedActs.length > 1) {\n      const acts = data.map(d => d.act).filter(distinct)\n      acts.map(function (act, i) {\n        const actChapters = data.filter(d => d.act === act).map(d => d.chapter).filter(distinct)\n        const middleChapter = actChapters[Math.floor(actChapters.length / 2)]\n\n        const square = colourLegend\n          .append('path')\n          .attr('d', d3.symbol().type(d3.symbolSquare).size(symbolSize))\n          .attr('transform', `translate(${Math.sqrt(symbolSize)},\n                                          ${(i - acts.length + 1) * 2 * Math.sqrt(symbolSize)})`)\n\n        if (middleChapter in colour[act]) {\n          square.attr('fill', colour[act][middleChapter])\n        } else {\n          square.attr('fill', '#787878')\n        }\n\n        colourLegend\n          .append('text')\n          .text(act)\n          .attr('transform', `translate(${2 * Math.sqrt(symbolSize)},\n                                          ${((i - acts.length + 1) * 2 + 0.25) * Math.sqrt(symbolSize)})`)\n\n        return 0\n      })\n\n      colourLegend\n        .append('text')\n        .text('Act:')\n        .attr('transform', `translate(${0.5 * Math.sqrt(symbolSize)},\n                                        ${(-acts.length * 2 + 0.25) * Math.sqrt(symbolSize)})`)\n    } else if (zoomedActs.length === 1) {\n      const act = zoomedActs[0]\n      const chapters = data.filter(d => d.act === act).map(d => d.chapter).filter(distinct).sort((a, b) => compareChapterColours(act, a, b))\n      chapters.map(function (chapter, i) {\n        const square = colourLegend\n          .append('path')\n          .attr('d', d3.symbol().type(d3.symbolSquare).size(symbolSize))\n          .attr('transform', `translate(${Math.sqrt(symbolSize)},\n                                          ${(i - chapters.length + 1) * 2 * Math.sqrt(symbolSize)})`)\n\n        if (chapter in colour[act]) {\n          square.attr('fill', colour[act][chapter])\n        } else {\n          square.attr('fill', '#AAAA00')\n        }\n\n        colourLegend\n          .append('text')\n          .text(chapter)\n          .attr('transform', `translate(${2 * Math.sqrt(symbolSize)},\n                                          ${((i - chapters.length + 1) * 2 + 0.25) * Math.sqrt(symbolSize)})`)\n\n        return 0\n      })\n\n      colourLegend\n        .append('text')\n        .text('Chapter:')\n        .attr('transform', `translate(${0.5 * Math.sqrt(symbolSize)},\n                                        ${(-chapters.length * 2 + 0.25) * Math.sqrt(symbolSize)})`)\n    }\n\n    Streamlit.setFrameHeight()\n  }\n\n  public render = (): ReactNode => {\n    const data = this.get_data()\n    const [width, height, margin] = this.get_dimensions()\n    const stTheme = this.get_theme()\n\n    const distinct = (value, index, self): boolean => {\n      return self.indexOf(value) === index\n    }\n\n    const episodes = data.map(d => d.episode.toString())\n      .filter(distinct)\n\n    NUM_EPISODES = episodes.length\n    D3_DIV_ID = `bar_plot_component_${this.props.args.key}`\n\n    const marks = {}\n    episodes.map((d, i) => { marks[i + 1] = `${d}`; return 0 })\n\n    return (\n      <span>\n        <div id={D3_DIV_ID} />\n\n        <div style={{ margin: `40px ${margin.right / 2}px 40px ${margin.left / 2}px` }} id={D3_DIV_ID + '_silder'}>\n          <ConfigProvider\n            theme={{\n              token: {\n                colorPrimary: stTheme?.secondaryBackgroundColor,\n                colorFillContentHover: stTheme?.secondaryBackgroundColor,\n                colorPrimaryBorder: stTheme?.secondaryBackgroundColor,\n                colorPrimaryBorderHover: stTheme?.secondaryBackgroundColor\n              }\n            }}\n          >\n            <Slider\n              range\n              id='zoomSlider'\n              min={1}\n              max={NUM_EPISODES}\n              marks={marks}\n              step={1}\n              defaultValue={[1, NUM_EPISODES]}\n              onAfterChange={this.handleChangeEpisodeBounds}\n              tooltip={{ open: false }}\n              disabled={this.props.disabled}\n            />\n          </ConfigProvider>\n        </div>\n      </span>\n    )\n  }\n\n  /**\n   * Zoom the bar plot based on the boundry values returned from the slider.\n   *\n   * @param {[Number, Number]} value Start and end episodes to zoom to.\n   * @param {Number} duration Duration of the zoom animation.\n   */\n  private readonly handleChangeEpisodeBounds = (value, duration = 800): void => {\n    const margin = { top: 30, right: 220, bottom: 30, left: 80 }\n    const width = 1200 - margin.left - margin.right\n    const height = 600 - margin.top - margin.bottom\n\n    const startEpisode = value[0]\n    const endEpisode = value[1]\n    const displayedEpisodes = endEpisode - startEpisode + 1\n    const svg = d3.select('#' + D3_DIV_ID).select('svg').select('g')\n    const xAxis = svg.select('#myXaxis')\n\n    let episodes: any[] = []\n    const episodeXaxis = {}\n\n    svg.selectAll('.dataRect')\n      .each(function (d) {\n        episodes.push(d.episode)\n      })\n\n    const distinct = (value, index, self): boolean => {\n      return self.indexOf(value) === index\n    }\n\n    episodes = episodes.filter(distinct)\n    episodes.map((e, i) => { episodeXaxis[e] = i + 1; return 0 })\n\n    // Change the axes of the chart based on the zoom event.\n    function zoomChart (event): void {\n      const x = d3.scaleLinear()\n        .domain([0.5, NUM_EPISODES + 0.5])\n        .range([0, width])\n      const newX = event.transform.rescaleX(x)\n\n      // Update Xaxis with these new boundaries.\n      xAxis.call(d3.axisBottom(newX)\n        .ticks(displayedEpisodes)\n        .tickFormat((i) => i - 1 > -1 && i - 1 < episodes.length ? `Episode ${episodes[i - 1]}` : '')\n        .tickSize(0)\n      )\n      xAxis.selectAll('.tick text')\n        .attr('font-size', `${Math.min(150 / displayedEpisodes, 20)}`)\n\n      svg.selectAll('.dataRect')\n        .attr('x', d => newX(d.startTime + episodeXaxis[d.episode] - 0.5))\n        .attr('width', d => newX(d.endTime + episodeXaxis[d.episode] - 0.5) - newX(d.startTime + episodeXaxis[d.episode] - 0.5))\n        .attr('stroke-width', `${Math.min(0.7, 4 / (displayedEpisodes))}`)\n\n      svg.selectAll('.gridLine')\n        .attr('d', d => {\n          const path = d3.path()\n          path.moveTo(newX(d), 0)\n          path.lineTo(newX(d), height + 10)\n          return path\n        })\n    }\n\n    const zoom = d3.zoom()\n      .scaleExtent([1, NUM_EPISODES])\n      .on('zoom', zoomChart)\n\n    // Create a new zoom event and change it to fit the episode boundries.\n    const myZoom = _.cloneDeep(d3.zoomIdentity)\n    myZoom.k = NUM_EPISODES / displayedEpisodes\n    myZoom.x = (1 - startEpisode) * (width / displayedEpisodes)\n\n    svg.transition().duration(duration)\n      .call(zoom.transform, myZoom)\n\n    this.setState({ zoom: [startEpisode, endEpisode] })\n  }\n}\n\nexport default withStreamlitConnection(BarPlotComponent)\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport BarPlotComponent from \"./BarPlotComponent\"\n\nReactDOM.render(\n  <React.StrictMode>\n    <BarPlotComponent />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n)\n"],"sourceRoot":""}